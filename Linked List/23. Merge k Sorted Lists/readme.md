  # 23. Merge k Sorted Lists
 
  ## 1. 预备数据结构基础
 
  ### 1.1 胜者树
 
  胜者树是k路归并问题中经常使用的一种**完全二叉树**，其标准定义为：每个叶子结点代表一个原始数组中的元素，每个非叶子结点node的值为node的左子结点和右子结点中的较小值（一般定义数值较小者为胜者）。下图就是一个简单的胜者树示例。
  
  ![avatar](https://raw.githubusercontent.com/Happyxianyueveryday/Leetcode-Notebook/master/Linked%20List/23.%20Merge%20k%20Sorted%20Lists/1350310110_2414.jpg)
  
  #### A. 胜者树的调整
  当一个叶子结点的值改变时，胜者树都需要进行一次**调整**。**调整**的基本算法如下所示。
  
  > 1. 找到值发生改变的叶子结点node的父结点father(1)，修改该父结点的值为其左子结点和右子结点的最小值。
  > 2. 找到father(1)的父结点father(2)，修改该父结点的值为其左子结点和右子结点的最小值。
  > ...
  > 3. 找到father(n-1)的父结点father(n)，修改该父结点的值为其左子结点和右子结点的最小值。
  > 3. father(n)的父结点不存在（即father(n)为根结点时），停止上述的迭代过程，这时胜者树的根节点就是最终的胜者。
  
  #### B. 胜者树的数组实现
  这一部分实际上是整个本题最难的部分，如果没有一定的经验，面试中很难在短时间写出bugfree且简明清晰的胜者树数组实现。
  
  虽然网上已经存在一些实现方法，例如https://www.cnblogs.com/iyjhabc/p/3141665.html ，但是在个人看来其中的实现方法并不直观，下面给出我的实现方案。该实现方案直接按照上面的胜者树的示例图进行实现。
  
  下面先给出具体实现方法：
  
  ##### (1). 胜者树的数组建立方法：
  > 1. 确定数组的长度：假设为k路归并，则胜者树的结点数目为2\*k-1，需要创建的数组（下文记为lis）的长度为2\*k，其中lis\[0]不使用。
  > 2. 在数组中初始化叶子结点：数组lis的末k个元素即为叶子结点，因此向倒数k个元素中依次填入k路归并指针指向的k个数值
  > 3. 在数组中更新非叶子结点：从倒数第(k+1)个元素开始倒序进行更新，更新公式为：lis\[i]=min(lis\[2\*i],lis\[2\*i+1])，即每个非叶子结点的值为其两个儿子中的较小值。
  
  ##### (2). 胜者树的数组调整方法：
  假设值发生改变的叶子结点为lis\[i]。
  > 1. 迭代执行下面的伪代码，直到i==1时停止。
  
      i=i/2                           /*找到叶子结点的父结点*/
      lis[i]=min(lis[2*i],lis[2*i+1]) /*修改父结点为其两个子结点中的较小值*/   
      
  > 2. 迭代完成后就完成了败者树的数组调整，lis\[i]就是新的所求的最小值。
  
  ##### (3). 相关证明：
  > 1. 为什么k路归并的胜者树的结点数目为2\*k-1？
  
    证明: 根据完全二叉树的性质，完全二叉树中度为1的结点最多只有1个或者0个，当度为1的结点的数目为1时，总结点数=叶子结点数*2，当度为0的结点数目为0时，总结点数=2*叶子结点数-1。而根据败者树的定义，所有的非叶子结点的值都是根据该结点的两个儿子中的较小值，因此不允许存在度为1的叶子结点。故总结点数=2*叶子结点数-1=2*k-1。
  
  > 2. 为什么数组的末k个元素即为叶子结点？
  
     证明: 根据规定，一个结点的下标为i，则左子结点的下标为2*i，右子结点的下标为2*i+1，这时完全二叉树的数组实现就是完全二叉树的层次遍历序列。
  
  > 3. 更新非叶子结点时为什么按照倒序进行更新？
  
     证明: 前面说过，完全二叉树的数组实现就是完全二叉树的层次遍历序列。因此倒序更新才是自底向上更新，而正序更新是自顶向上更新，不符合胜者树的规则。
  
  
  
  
  ### 1.2 败者树
 
  败者树在胜者树上做了较小的修改，是胜者树的一种变体。**在败者树中，用父结点记录其左右子结点进行比赛的败者，而让胜者参加下一轮的比赛**。败者树的根结点记录的是败者，需要加一个结点来记录整个比赛的胜利者。下图为一个简单的败者树示例。
  
  ![avatar](https://raw.githubusercontent.com/Happyxianyueveryday/Leetcode-Notebook/master/Linked%20List/23.%20Merge%20k%20Sorted%20Lists/1350310705_4079.jpg)
  
  #### A. 败者树的调整
  与胜者树相同，每当一个叶子结点的值改变时，败者树都需要进行一次**调整**，**调整**的基本算法如下所示。
  > 1. 找到值发生改变的叶子结点node的父结点father(1)，修改该父结点的值为其本身和node的值中的较大值max(1)，而将其较小值min(1)保存以继续进行比赛。
  > 2. 找到father(1)的父结点father2，修改该父结点的值为其本身和min(1)中的较大值，记为max(2)，而将其中的较小值min(2)保存以继续进行比赛。
  > 3. ...
  > 4. 找到father(n-1)的父结点father(n)，修改该父结点的值为其本身和min(n-1)中的较大值，记为max(n)，而将其中的较小值min(n)保存以继续进行比赛。
  > 5. fathern的父结点不存在（即fathern为根结点），此时的min(n)就是最终的新的胜者。
  
  #### B. 败者树的数组实现
  
  
  ## 2. 基本算法思想
  按照如下的算法进行K路归并。
  
  > 1. 
  
  
  ## 3. 伪代码实现
  
  
  ## 4. 易错的边缘情况
  
  
  ## 5. 实现代码
  
  ## 6. 一个典型的示例
  
  ## 7. 复杂度分析
  
  
  
  
  
