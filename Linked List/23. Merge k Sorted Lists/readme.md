  # 23. Merge k Sorted Lists
 
  ## 1. 预备数据结构基础
 
  k路归并中主要使用的数据结构为胜者树或者败者树，胜者树和败者树在原理上是完全相同的，仅仅是在具体实现上有一定的差距，具体实现中只需要熟练掌握其中一种，本题中均使用胜者树进行实现，但也会简单补充一部分败者树的基本内容。
  
  ### 1.1 胜者树
 
  胜者树是k路归并问题中经常使用的一种**完全二叉树**，其标准定义为：每个叶子结点代表一个原始数组中的元素，每个非叶子结点node的值为node的左子结点和右子结点中的较小值（一般定义数值较小者为胜者）。下图就是一个简单的胜者树示例。
  
  ![avatar](https://raw.githubusercontent.com/Happyxianyueveryday/Leetcode-Notebook/master/Linked%20List/23.%20Merge%20k%20Sorted%20Lists/1350310110_2414.jpg)
  
  #### A. 胜者树的调整
  当一个叶子结点的值改变时，胜者树都需要进行一次**调整**。**调整**的基本算法如下所示。
  
  > 1. 找到值发生改变的叶子结点node的父结点father(1)，修改该父结点的值为其左子结点和右子结点的最小值。
  > 2. 找到father(1)的父结点father(2)，修改该父结点的值为其左子结点和右子结点的最小值。
  > 3. ...
  > 4. 找到father(n-1)的父结点father(n)，修改该父结点的值为其左子结点和右子结点的最小值。
  > 5. father(n)的父结点不存在（即father(n)为根结点时），停止上述的迭代过程，这时胜者树的根节点就是最终的胜者。
  
  #### B. 胜者树的数组实现
  这一部分实际上是整个本题最难的部分，如果没有一定的经验，面试中很难在短时间写出bugfree且简明清晰的胜者树数组实现。
  
  虽然网上已经存在一些实现方法，例如https://www.cnblogs.com/iyjhabc/p/3141665.html ，但是在个人看来其中的实现方法并不直观，下面给出我的实现方案。该实现方案直接按照上面的胜者树的示例图进行实现。
  
  下面先给出具体实现方法：
  
  ##### (1). 胜者树的数组建立方法：
  
  > 0. 确定数组的下标规则：下标为0的数组元素不使用，根结点在数组中的下标为1，下标为i的结点的左子结点和右子结点的下标分别为2\*i和2\*i+1。
  > 1. 确定数组的长度：假设为k路归并，则胜者树的结点数目为2\*k-1，需要创建的数组（下文记为lis）的长度为2\*k，其中lis\[0]不使用。
  > 2. 在数组中初始化叶子结点：数组lis的末k个元素即为叶子结点，因此向倒数k个元素中依次填入k路归并指针指向的k个数值。
  > 3. 在数组中更新非叶子结点：从倒数第(k+1)个元素开始倒序进行更新，更新公式为：lis\[i]=min(lis\[2\*i],lis\[2\*i+1])，即每个非叶子结点的值为其两个儿子中的较小值。
  
  ##### (2). 胜者树的数组调整方法：
  假设值发生改变的叶子结点为lis\[i]。
  > 1. 迭代执行下面的伪代码，直到i==1时停止。
  
      i=i/2                           /*找到叶子结点的父结点*/
      lis[i]=min(lis[2*i],lis[2*i+1]) /*修改父结点为其两个子结点中的较小值*/   
      
  > 2. 迭代完成后就完成了败者树的数组调整，lis\[i]就是新的所求的最小值。
  
  ##### (3). 相关证明：
  > 1. 为什么k路归并的胜者树的结点数目为2\*k-1？
  
    证明: 根据完全二叉树的性质，完全二叉树中度为1的结点最多只有1个或者0个，当度为1的结点的数目为1时，总结点数=叶子结点数*2，当度为0的结点数目为0时，总结点数=2*叶子结点数-1。而根据败者树的定义，所有的非叶子结点的值都是根据该结点的两个儿子中的较小值，因此不允许存在度为1的叶子结点。故总结点数=2*叶子结点数-1=2*k-1。
  
  > 2. 为什么数组的末k个元素即为叶子结点？
  
     证明: 根据规定，一个结点的下标为i，则左子结点的下标为2*i，右子结点的下标为2*i+1，这时完全二叉树的数组实现就是完全二叉树的层次遍历序列。
  
  > 3. 更新非叶子结点时为什么按照倒序进行更新？
  
     证明: 前面说过，完全二叉树的数组实现就是完全二叉树的层次遍历序列。因此倒序更新才是由叶子结点开始自底向上更新，而正序更新是从根结点自顶向下更新，不符合胜者树的规则。
  
  
  
  
  ### 1.2 败者树
 
  败者树在胜者树上做了较小的修改，是胜者树的一种变体。**在败者树中，用父结点记录其左右子结点进行比赛的败者，而让胜者参加下一轮的比赛**。败者树的根结点记录的是败者，需要加一个结点来记录整个比赛的胜利者。下图为一个简单的败者树示例。
  
  ![avatar](https://raw.githubusercontent.com/Happyxianyueveryday/Leetcode-Notebook/master/Linked%20List/23.%20Merge%20k%20Sorted%20Lists/1350310705_4079.jpg)
  
  #### A. 败者树的调整
  与胜者树相同，每当一个叶子结点的值改变时，败者树都需要进行一次**调整**，**调整**的基本算法如下所示。
  > 1. 找到值发生改变的叶子结点node的父结点father(1)，修改该父结点的值为其本身和node的值中的较大值max(1)，而将其较小值min(1)保存以继续进行比赛。
  > 2. 找到father(1)的父结点father2，修改该父结点的值为其本身和min(1)中的较大值，记为max(2)，而将其中的较小值min(2)保存以继续进行比赛。
  > 3. ...
  > 4. 找到father(n-1)的父结点father(n)，修改该父结点的值为其本身和min(n-1)中的较大值，记为max(n)，而将其中的较小值min(n)保存以继续进行比赛。
  > 5. fathern的父结点不存在（即fathern为根结点），此时的min(n)就是最终的新的胜者。
  
  #### B. 败者树的数组实现
  本部分实现和胜者树类似。本实验中主要使用胜者树实现，因此本部分略去。
  
  
  ## 2. 解题算法
  按照如下的算法进行K路归并，这里作为实现基础的数据结构为胜者树。
  
  > 1. 初始化一个含有k个指针的数组pos，其中指针pos\[i]为指向一个指向链表i的头结点，这k个指针分别作为各个待归并链表的游标结点。
  > 2. 初始化一个含有k个数值的数组lis，其中lis\[i]为指针pos\[i]所指向的链表结点的值。
  > 3. 根据上述初始化完成的数组pos和lis，建立一个含有2\*k个元素胜者树tree（建立过程见上面的胜者树建立方法部分）；并同时建立一个等长度的胜者树结点下标数组nodeindex，其中nodeindex\[i]是败者树结点tree\[i]的值在lis中的对应下标m。
  > 4. 迭代执行下面的步骤a——步骤e，直到指针数组pos中的每一个指针均指向空结点NULL为止。
  >> a. 取出胜者树tree的根节点的值tree\[1]，将该值加入归并结果链表res中。  
  >> b. 更新游标指针pos\[nodeindex[1]]：即pos\[nodeindex\[1]]=pos\[nodeindex\[1]].next，因为nodeindex\[1]为根节点的值所来自的待归并链表的下标。  
  >> c. 更新胜者树的叶子结点为新的值：即tree\[k+nodeindex\[1]]=(pos\[nodeindex\[1]]==NULL)?pos\[nodeindex\[1]].val:INT_MAX。  
  >> d. 更新数组lis中对应元素的值：即lis\[nodeindex\[i]]=(pos\[nodeindex\[1]]==NULL)?pos\[nodeindex\[1]].val:INT_MAX。  
  >> e. 重新调整胜者树（调整过程见上面的胜者树建立方法部分）。  
  > 5. 返回归并结果链表res。  
  
  ## 3. 易错的边缘情况
  
  > 1. 多个归并链表的长度不一致
  > 2. 多个归并链表中存在空链表
  > 3. 没有待归并的链表
  
  
  ## 4. 实现代码
  C++版本和python版本使用的均是胜者树，C++版本请参见本文件夹下的23. Merge k Sorted Lists.cpp；python版本请参见本文件夹下的23. Merge k Sorted Lists.py。
  
  ## 5. 复杂度分析
  > 1. 首先我们估计胜者树或者败者树的一次调整所需要的时间。从上述的分析中可知胜者树或者败者树的结点总数为2k个。每次调整过程需要从叶子结点开始，沿着父结点一路到达根结点，每到一个结点需要求一次两个数之间的最小值，因此需要访问的结点数目为log(2k)个。综上所述，一次胜者树或者败者树的调整的时间复杂度为O(log2k)。
  > 2. 然后我们分析归并过程，归并过程中对于每个链表元素都需要访问一次，每访问一次就需要调整一次胜者树或者败者树。
  > 3. 因此，总的时间复杂度为O(nlog(2k))，其中k为归并路数，n为k个链表的结点总数。
  
  ## 7. 一个基于胜者树的五路归并的可视化过程
  
  
 
  
  
  
  
  
