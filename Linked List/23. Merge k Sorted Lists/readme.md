  # 23. Merge k Sorted Lists
 
  ## 1. 预备数据结构基础
 
  ### 1.1 胜者树
 
  胜者树是k路归并问题中经常使用的一种完全二叉树，其标准定义为：每个叶子结点代表一个原始数组中的元素，每个非叶子结点node的值为node的左子结点和右子结点中的较小值（一般定义数值较小者为胜者）。下图就是一个简单的胜者树示例。
  
  ![avatar](https://raw.githubusercontent.com/Happyxianyueveryday/Leetcode-Notebook/master/Linked%20List/23.%20Merge%20k%20Sorted%20Lists/1350310110_2414.jpg)
 
  胜者树主要有两个基本操作：**调整**和**建立**。
  
  #### A. 胜者树的调整
  当一个叶子结点的值改变时，胜者树都需要进行一次**调整**。**调整**的基本算法如下所示。
  
  > 1. 找到值发生改变的叶子结点node的父结点father1，修改该父结点的值为其左子结点和右子结点的最小值。
  > 2. 找到father1的父结点father2，修改该父结点的值为其左子结点和右子结点的最小值。
  > ...
  > 3. 重复上述步骤，直到找不到fathern的父结点（即fathern为根结点时）停止。
  
  #### B. 胜者树的建立
  胜者树的建立操作是在调整操作的基础上进行的，其基本算法如下所示。
  > 1. 将胜者树的叶子结点全部初始化为一个最大值（例如INT_MAX）
  > 2. 依次修改各个叶子结点为数组元素的值，并在每次修改后进行一次胜者树的调整操作即可完成
  
  ### 1.2 败者树
 
  败者树在胜者树上做了较小的修改，是胜者树的一种变体。在败者树中，用父结点记录其左右子结点进行比赛的败者，而让胜者参加下一轮的比赛。败者树的根结点记录的是败者，需要加一个结点来记录整个比赛的胜利者。下图为一个简单的败者树示例。
  
  ![avatar](https://raw.githubusercontent.com/Happyxianyueveryday/Leetcode-Notebook/master/Linked%20List/23.%20Merge%20k%20Sorted%20Lists/1350310705_4079.jpg)
  
  #### A. 败者树的调整
  与胜者树相同，每当一个叶子结点的值改变时，败者树都需要进行一次**调整**，**调整**的基本算法如下所示。
  > 1. 找到值发生改变的叶子结点node的父结点father1，修改该父结点的值为其本身和node的值中的较大值max1，而将其较小值min1保存以继续进行比赛。
  > 2. 找到father1的父结点father2，修改该父结点的值为其本身和min1中的较大值max2，而将其中的较小值min2保存以继续进行比赛。
  > ...
  > 3. 重复上述步骤，直到找不到fathern的父结点（即fathern为根结点时）停止，此时的minn就是最终的新的胜者。
  
  **通常而言，在实际的k路归并算法题中，我们更推荐直接使用改进版本的胜者树——败者树进行快速实现。**
  
  ### 1.3. 败者树的数组表示
  这一部分实际上是整个本题最难的部分，如果没有一定的经验，很难在短时间内想出如何使用数组方便地表示一个败者树，
  
  ## 2. 基本算法思想
  
  
  
  ## 3. 伪代码实现
  
  
  ## 4. 易错的边缘情况
  
  
  ## 5. 实现代码
  
  
  ## 6. 复杂度分析
  
  
  
  
  
