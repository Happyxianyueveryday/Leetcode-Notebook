  # 23. Merge k Sorted Lists
 
  ## 1. 预备数据结构基础
 
  ### 1.1 胜者树
 
  胜者树是k路归并问题中经常使用的一种**完全二叉树**，其标准定义为：每个叶子结点代表一个原始数组中的元素，每个非叶子结点node的值为node的左子结点和右子结点中的较小值（一般定义数值较小者为胜者）。下图就是一个简单的胜者树示例。
  
  ![avatar](https://raw.githubusercontent.com/Happyxianyueveryday/Leetcode-Notebook/master/Linked%20List/23.%20Merge%20k%20Sorted%20Lists/1350310110_2414.jpg)
 
  胜者树主要有两个基本操作：**调整**和**建立**。
  
  ##### A. 胜者树的调整
  当一个叶子结点的值改变时，胜者树都需要进行一次**调整**。**调整**的基本算法如下所示。
  
  > 1. 找到值发生改变的叶子结点node的父结点father1，修改该父结点的值为其左子结点和右子结点的最小值。
  > 2. 找到father1的父结点father2，修改该父结点的值为其左子结点和右子结点的最小值。
  > ...
  > 3. 重复上述步骤，直到找不到fathern的父结点（即fathern为根结点时）停止。
  
  ##### B. 胜者树的建立
  胜者树的建立操作是在调整操作的基础上进行的，其基本算法如下所示。
  > 1. 将胜者树的叶子结点全部初始化为一个最大值（例如INT_MAX）
  > 2. 依次修改各个叶子结点为数组元素的值，并在每次修改后进行一次胜者树的调整操作即可完成建立
  
  ### 1.2 败者树
 
  败者树在胜者树上做了较小的修改，是胜者树的一种变体。在败者树中，用父结点记录其左右子结点进行比赛的败者，而让胜者参加下一轮的比赛。败者树的根结点记录的是败者，需要加一个结点来记录整个比赛的胜利者。下图为一个简单的败者树示例。
  
  ![avatar](https://raw.githubusercontent.com/Happyxianyueveryday/Leetcode-Notebook/master/Linked%20List/23.%20Merge%20k%20Sorted%20Lists/1350310705_4079.jpg)
  
  ##### A. 败者树的调整
  与胜者树相同，每当一个叶子结点的值改变时，败者树都需要进行一次**调整**，**调整**的基本算法如下所示。
  > 1. 找到值发生改变的叶子结点node的父结点father1，修改该父结点的值为其本身和node的值中的较大值max1，而将其较小值min1保存以继续进行比赛。
  > 2. 找到father1的父结点father2，修改该父结点的值为其本身和min1中的较大值max2，而将其中的较小值min2保存以继续进行比赛。
  > ...
  > 3. 重复上述步骤，直到找不到fathern的父结点（即fathern为根结点时）停止，此时的minn就是最终的新的胜者。
  
  ##### B. 败者树的建立
  败者树的建立操作同样是在调整操作的基础上进行的，其基本算法如下所示。
  > 1. 将败者树的叶子结点全部初始化为一个最大值（例如INT_MAX）
  > 2. 依次修改各个叶子结点为数组元素的值，并在每次修改后进行一次败者树的调整操作即可完成建立
  
  
  ### 1.3. 胜者树的数组表示和实现技巧
  这一部分实际上是整个本题最难的部分，如果没有一定的经验，面试中很难在短时间写出bugfree且简明清晰的胜者树数组实现。
  
  虽然网上已经存在一些实现方法，例如https://www.cnblogs.com/iyjhabc/p/3141665.html ，但是在个人看来其中的实现方法并不直观，下面给出我的实现方案。该实现方案直接按照上面的胜者树的示例图进行实现。
  
  下面先给出具体实现方法：
  
  + 败者树的数组实现方法：
  > 1. 确定数组的长度：假设为k路归并，则胜者树的结点数目为2\*k-1，需要创建的数组（下文记为lis）的长度为2\*k，其中lis\[0]不使用。
  > 2. 在数组中初始化叶子结点：数组lis的末k个元素即为叶子结点，因此向倒数k个元素中依次填入k路归并指针指向的k个数值
  > 3. 在数组中更新非叶子结点：从倒数第(k+1)个元素开始倒序进行更新，更新公式为：lis\[i]=min(lis\[2\*i],lis\[2\*i+1])，即，即每个非叶子结点的值为其两个儿子中的较小值。
  
  + 相关证明：
  > 1. 为什么k路归并的败者树的结点数目为2\*k-1？
  
    证明: 根据完全二叉树的性质，完全二叉树中度为1的结点最多只有1个或者0个，当度为1的结点的数目为1时，总结点数=叶子结点数*2，当度为0的结点数目为0时，总结点数=2*叶子结点数-1。而根据败者树的定义，所有的非叶子结点的值都是根据该结点的两个儿子中的较小值，因此不允许存在度为1的叶子结点。故总结点数=2*叶子结点数-1=2*k-1。
  
  > 2. 为什么数组的末k个元素即为叶子结点？
  
     证明: 根据规定，一个结点的下标为i，则左子结点的下标为2*i，右子结点的下标为2*i+1，这时完全二叉树的数组实现就是完全二叉树的层次遍历序列，直接画如下的草图即可说明。
     <.......................>
  
  > 3. 更新非叶子结点时为什么按照倒序进行更新？
  
     证明: 前面说过，完全二叉树的数组实现就是完全二叉树的层次遍历序列。
  
  
  
  ## 2. 基本算法思想
  
  
  
  ## 3. 伪代码实现
  
  
  ## 4. 易错的边缘情况
  
  
  ## 5. 实现代码
  
  
  ## 6. 复杂度分析
  
  
  
  
  
